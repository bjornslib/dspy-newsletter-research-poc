#!/bin/bash
# Advisory Report Generation Utility
# Epic 5: Advisory Reporting (agencheck-r1m)
#
# Implements:
#   AC-16: Generate consolidated reports in .claude/reports/post-push/
#   AC-17: Report includes: Summary, Security, Code Quality, Documentation, File Movements, Recommendations
#   AC-18: Advisory-only (no blocking, user can continue)
#   AC-19: User notification via systemMessage
#
# Usage:
#   source .claude/utils/advisory-report.sh
#   # Then call functions directly
#
# Or run directly:
#   .claude/utils/advisory-report.sh generate [options]
#
# Commands:
#   generate           - Generate a new advisory report
#   list               - List existing reports
#   show <report>      - Display a specific report
#   summary            - Show summary of latest report
#   notification       - Generate systemMessage notification JSON

set -euo pipefail

# ============================================
# CONFIGURATION
# ============================================

# Report output directory (AC-16)
REPORT_DIR="${REPORT_DIR:-.claude/reports/post-push}"

# Report sections (AC-17)
REPORT_SECTIONS=("summary" "security" "code-quality" "documentation" "file-movements" "recommendations")

# Timestamp format
TIMESTAMP_FORMAT="%Y-%m-%d-%H-%M-%S"
DATETIME_FORMAT="%Y-%m-%d %H:%M:%S UTC"

# ============================================
# UTILITY FUNCTIONS
# ============================================

# Get current timestamp for report filename
get_report_timestamp() {
    date -u +"$TIMESTAMP_FORMAT"
}

# Get human-readable datetime
get_datetime() {
    date -u +"$DATETIME_FORMAT"
}

# Ensure report directory exists (AC-16)
ensure_report_dir() {
    if [ ! -d "$REPORT_DIR" ]; then
        mkdir -p "$REPORT_DIR"
    fi

    # Create INDEX.md if it doesn't exist
    local index_file="${REPORT_DIR}/INDEX.md"
    if [ ! -f "$index_file" ]; then
        cat > "$index_file" << 'EOF'
# Post-Push Review Reports Index

This directory contains advisory reports generated after each git push.

## Reports

| Date | Branch | Commits | Status |
|------|--------|---------|--------|
<!-- REPORT_ENTRIES -->

## Usage

Reports are automatically generated by the `codebase-quality:post-push` skill.

To manually generate a report:
```bash
/codebase-quality post-push
```

To view the latest report:
```bash
.claude/utils/advisory-report.sh summary
```

---

**Note**: All reports are advisory only. No actions are required.
EOF
    fi
}

# ============================================
# AC-16: REPORT GENERATION
# ============================================

# Initialize a new report with metadata
init_report() {
    local branch="${1:-main}"
    local commit_count="${2:-0}"
    local commit_range="${3:-HEAD~1..HEAD}"
    local is_first_push="${4:-false}"
    local is_force_push="${5:-false}"

    local timestamp
    timestamp=$(get_report_timestamp)
    local datetime
    datetime=$(get_datetime)

    local report_file="${REPORT_DIR}/${timestamp}.md"

    ensure_report_dir

    # Create report with header
    cat > "$report_file" << EOF
# Post-Push Review Report

**Push**: ${branch} ‚Üí origin/${branch}
**Commits**: ${commit_count} (${commit_range})
**Time**: ${datetime}
**First Push**: ${is_first_push}
**Force Push**: ${is_force_push}

---

EOF

    echo "$report_file"
}

# ============================================
# AC-17: REPORT SECTIONS
# ============================================

# Generate summary section (AC-17)
generate_summary_section() {
    local security_status="${1:-‚úÖ Pass}"
    local security_issues="${2:-0}"
    local code_quality_status="${3:-‚úÖ Pass}"
    local code_quality_issues="${4:-0}"
    local documentation_status="${5:-‚úÖ Pass}"
    local documentation_issues="${6:-0}"
    local lifecycle_status="${7:-‚úÖ Pass}"
    local lifecycle_transitions="${8:-0}"

    cat << EOF
## üìä Summary

| Category | Status | Issues |
|----------|--------|--------|
| Security | ${security_status} | ${security_issues} |
| Code Quality | ${code_quality_status} | ${code_quality_issues} |
| Documentation | ${documentation_status} | ${documentation_issues} |
| Doc Lifecycle | ${lifecycle_status} | ${lifecycle_transitions} transitions |

EOF
}

# Generate commits section
generate_commits_section() {
    local commit_list="$1"

    cat << EOF
## üìù Commits Analyzed

\`\`\`
${commit_list}
\`\`\`

EOF
}

# Generate security section (AC-17)
generate_security_section() {
    local findings="${1:-No security issues found.}"
    local severity="${2:-none}"

    local icon="üîí"
    if [ "$severity" = "critical" ] || [ "$severity" = "high" ]; then
        icon="üö®"
    elif [ "$severity" = "medium" ]; then
        icon="‚ö†Ô∏è"
    fi

    cat << EOF
## ${icon} Security Findings

${findings}

EOF
}

# Generate code quality section (AC-17)
generate_code_quality_section() {
    local findings="${1:-No code quality issues found.}"

    cat << EOF
## üßπ Code Quality Findings

${findings}

EOF
}

# Generate documentation section (AC-17)
generate_documentation_section() {
    local findings="${1:-Documentation is up to date.}"
    local lifecycle_summary="${2:-}"

    cat << EOF
## üìö Documentation Status

${findings}

EOF

    if [ -n "$lifecycle_summary" ]; then
        cat << EOF
### Document Lifecycle Summary

${lifecycle_summary}

EOF
    fi
}

# Generate file movements section (AC-17)
generate_file_movements_section() {
    local movements="${1:-}"

    if [ -z "$movements" ] || [ "$movements" = "[]" ]; then
        cat << EOF
## üìÅ File Movements

No document lifecycle transitions in this push.

EOF
    else
        cat << EOF
## üìÅ File Movements

| Document | From | To | Reason |
|----------|------|-----|--------|
${movements}

EOF
    fi
}

# Generate recommendations section (AC-17)
generate_recommendations_section() {
    local recommendations="${1:-}"

    if [ -z "$recommendations" ]; then
        cat << EOF
## üí° Recommendations

No specific recommendations at this time. Keep up the good work!

EOF
    else
        cat << EOF
## üí° Recommendations

${recommendations}

EOF
    fi
}

# Generate advisory footer (AC-18)
generate_advisory_footer() {
    cat << EOF
---

**Note**: This report is **advisory only**. No actions are required, and no blocking has occurred.

Report generated by \`codebase-quality:post-push\` skill.
EOF
}

# ============================================
# FULL REPORT GENERATION
# ============================================

# Generate complete advisory report
generate_report() {
    local branch="${1:-main}"
    local commit_count="${2:-0}"
    local commit_range="${3:-HEAD~1..HEAD}"
    local is_first_push="${4:-false}"
    local is_force_push="${5:-false}"

    # Initialize report
    local report_file
    report_file=$(init_report "$branch" "$commit_count" "$commit_range" "$is_first_push" "$is_force_push")

    # Get commit list
    local commit_list=""
    if [ -n "$commit_range" ] && [ "$commit_range" != "HEAD~1..HEAD" ]; then
        commit_list=$(git log --oneline "$commit_range" 2>/dev/null || echo "Unable to retrieve commit list")
    else
        commit_list=$(git log --oneline -n "${commit_count:-10}" 2>/dev/null || echo "Unable to retrieve commit list")
    fi

    # Append summary section (will be updated by orchestrator)
    generate_summary_section >> "$report_file"

    # Append commits section
    generate_commits_section "$commit_list" >> "$report_file"

    # Append placeholder sections (will be filled by skill invocations)
    cat >> "$report_file" << 'EOF'
## üîí Security Findings

*Pending analysis by codebase-quality:security skill...*

## üßπ Code Quality Findings

*Pending analysis by codebase-quality:code-quality skill...*

## üìö Documentation Status

*Pending analysis by codebase-quality:documentation skill...*

## üìÅ File Movements

*Pending analysis by document-lifecycle utility...*

## üí° Recommendations

*Will be generated after all analyses complete...*

EOF

    # Append advisory footer (AC-18)
    generate_advisory_footer >> "$report_file"

    echo "$report_file"
}

# Update a specific section in an existing report
update_report_section() {
    local report_file="$1"
    local section_header="$2"
    local new_content="$3"

    if [ ! -f "$report_file" ]; then
        echo '{"error": "Report file not found", "updated": false}'
        return 1
    fi

    # Create a temp file
    local temp_file
    temp_file=$(mktemp)

    # Use awk to replace section content
    awk -v section="$section_header" -v content="$new_content" '
    BEGIN { in_section = 0; printed = 0 }
    /^## / {
        if (in_section) {
            in_section = 0
        }
        if ($0 ~ section) {
            in_section = 1
            print $0
            print ""
            print content
            print ""
            printed = 1
            next
        }
    }
    !in_section { print }
    ' "$report_file" > "$temp_file"

    mv "$temp_file" "$report_file"

    echo '{"updated": true, "section": "'"$section_header"'"}'
}

# Finalize report with summary statistics
finalize_report() {
    local report_file="$1"
    local security_status="${2:-‚úÖ Pass}"
    local security_issues="${3:-0}"
    local code_quality_status="${4:-‚úÖ Pass}"
    local code_quality_issues="${5:-0}"
    local documentation_status="${6:-‚úÖ Pass}"
    local documentation_issues="${7:-0}"
    local lifecycle_status="${8:-‚úÖ Pass}"
    local lifecycle_transitions="${9:-0}"

    if [ ! -f "$report_file" ]; then
        echo '{"error": "Report file not found", "finalized": false}'
        return 1
    fi

    # Update summary section
    local summary
    summary=$(generate_summary_section "$security_status" "$security_issues" \
        "$code_quality_status" "$code_quality_issues" \
        "$documentation_status" "$documentation_issues" \
        "$lifecycle_status" "$lifecycle_transitions")

    update_report_section "$report_file" "üìä Summary" "$summary"

    # Update index
    update_report_index "$report_file"

    echo '{"finalized": true, "report": "'"$report_file"'"}'
}

# Update INDEX.md with new report entry
update_report_index() {
    local report_file="$1"
    local index_file="${REPORT_DIR}/INDEX.md"

    if [ ! -f "$index_file" ]; then
        ensure_report_dir
    fi

    # Extract report metadata
    local filename
    filename=$(basename "$report_file")
    local date_str
    date_str=$(echo "$filename" | sed 's/.md$//' | sed 's/-/ /g' | head -c 10)

    # Get branch from report
    local branch="main"
    if [ -f "$report_file" ]; then
        branch=$(grep -m1 "^\*\*Push\*\*:" "$report_file" 2>/dev/null | sed 's/.*: //' | cut -d' ' -f1 || echo "main")
    fi

    # Get commit count from report
    local commits="0"
    if [ -f "$report_file" ]; then
        commits=$(grep -m1 "^\*\*Commits\*\*:" "$report_file" 2>/dev/null | sed 's/.*: //' | cut -d' ' -f1 || echo "0")
    fi

    # Add entry to index (at the end of table)
    local entry="| ${date_str} | ${branch} | ${commits} | [View](${filename}) |"

    # Insert entry after the header row
    sed -i.bak '/<!-- REPORT_ENTRIES -->/a\
'"$entry"'' "$index_file"
    rm -f "${index_file}.bak"
}

# ============================================
# AC-19: NOTIFICATION MECHANISM
# ============================================

# Generate systemMessage notification JSON
generate_notification() {
    local report_file="$1"
    local security_issues="${2:-0}"
    local code_quality_issues="${3:-0}"
    local documentation_issues="${4:-0}"
    local lifecycle_transitions="${5:-0}"

    local total_issues=$((security_issues + code_quality_issues + documentation_issues))

    local status_emoji="‚úÖ"
    local status_text="All checks passed"

    if [ "$security_issues" -gt 0 ]; then
        status_emoji="üö®"
        status_text="Security issues found"
    elif [ "$code_quality_issues" -gt 0 ]; then
        status_emoji="‚ö†Ô∏è"
        status_text="Code quality issues found"
    elif [ "$documentation_issues" -gt 0 ]; then
        status_emoji="üìù"
        status_text="Documentation updates needed"
    elif [ "$lifecycle_transitions" -gt 0 ]; then
        status_emoji="üìÅ"
        status_text="Document lifecycle transitions detected"
    fi

    local report_path
    report_path=$(basename "$report_file")

    # Generate systemMessage JSON for hook response (AC-19)
    cat << EOF
{
    "systemMessage": "${status_emoji} Post-push review complete: ${status_text}. Found ${total_issues} issue(s) and ${lifecycle_transitions} lifecycle transition(s). Report: ${REPORT_DIR}/${report_path}",
    "summary": {
        "status": "${status_text}",
        "total_issues": ${total_issues},
        "security_issues": ${security_issues},
        "code_quality_issues": ${code_quality_issues},
        "documentation_issues": ${documentation_issues},
        "lifecycle_transitions": ${lifecycle_transitions}
    },
    "report_path": "${REPORT_DIR}/${report_path}",
    "advisory": true
}
EOF
}

# Generate simple notification message
generate_notification_message() {
    local report_file="$1"
    local security_issues="${2:-0}"
    local code_quality_issues="${3:-0}"
    local documentation_issues="${4:-0}"
    local lifecycle_transitions="${5:-0}"

    local total_issues=$((security_issues + code_quality_issues + documentation_issues))

    local status_emoji="‚úÖ"
    if [ "$security_issues" -gt 0 ]; then
        status_emoji="üö®"
    elif [ "$code_quality_issues" -gt 0 ]; then
        status_emoji="‚ö†Ô∏è"
    elif [ "$documentation_issues" -gt 0 ]; then
        status_emoji="üìù"
    fi

    local report_path
    report_path=$(basename "$report_file")

    echo "${status_emoji} Post-push review complete. Found ${total_issues} issue(s), ${lifecycle_transitions} lifecycle transition(s). Report: ${REPORT_DIR}/${report_path}"
}

# ============================================
# REPORT LISTING & VIEWING
# ============================================

# List all reports
list_reports() {
    local limit="${1:-10}"

    ensure_report_dir

    echo "Recent Post-Push Reports (last ${limit}):"
    echo "=========================================="

    # List reports, newest first
    find "$REPORT_DIR" -name "*.md" -type f ! -name "INDEX.md" | \
        sort -r | \
        head -n "$limit" | \
        while read -r report; do
            local filename
            filename=$(basename "$report")
            local date_str
            date_str=$(echo "$filename" | sed 's/.md$//' | sed 's/-/:/4' | sed 's/-/:/5')
            echo "  - $date_str: $report"
        done
}

# Get latest report
get_latest_report() {
    find "$REPORT_DIR" -name "*.md" -type f ! -name "INDEX.md" | sort -r | head -1
}

# Show report summary
show_summary() {
    local report_file="${1:-$(get_latest_report)}"

    if [ -z "$report_file" ] || [ ! -f "$report_file" ]; then
        echo "No reports found."
        return 1
    fi

    echo "Latest Report: $report_file"
    echo "=============================="

    # Extract and display summary section
    sed -n '/^## üìä Summary/,/^## /p' "$report_file" | head -n -1
}

# ============================================
# CLI INTERFACE
# ============================================

show_help() {
    cat << EOF
Advisory Report Generation Utility

Usage: $0 [command] [args...]

Commands:
    generate [options]          Generate a new advisory report
    list [limit]                List recent reports (default: 10)
    latest                      Show path to latest report
    summary [report]            Show summary of report (default: latest)
    notification <report> [stats]  Generate systemMessage notification JSON
    help                        Show this help message

Options for 'generate':
    --branch=<name>             Branch name (default: main)
    --commits=<count>           Number of commits
    --range=<range>             Commit range (e.g., abc123..HEAD)
    --first-push                Mark as first push
    --force-push                Mark as force push

Examples:
    $0 generate --branch=feature/new-feature --commits=5
    $0 generate --range=abc1234..HEAD
    $0 list 5
    $0 summary
    $0 notification ./reports/2025-01-01-12-00-00.md 2 3 0 1

Report Sections (AC-17):
    - Summary: Overall status table
    - Security: Findings from codebase-quality:security
    - Code Quality: Findings from codebase-quality:code-quality
    - Documentation: Document status and lifecycle
    - File Movements: Lifecycle transitions (files moved)
    - Recommendations: Prioritized action items

Advisory Mode (AC-18):
    All reports are advisory only. They never block the user's workflow.

Notification (AC-19):
    The notification command generates JSON suitable for systemMessage
    in hook responses, informing the user of the review results.

EOF
}

# Main CLI handler
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        generate)
            local branch="main"
            local commits="0"
            local range=""
            local first_push="false"
            local force_push="false"

            while [ $# -gt 0 ]; do
                case "$1" in
                    --branch=*)
                        branch="${1#*=}"
                        ;;
                    --commits=*)
                        commits="${1#*=}"
                        ;;
                    --range=*)
                        range="${1#*=}"
                        ;;
                    --first-push)
                        first_push="true"
                        ;;
                    --force-push)
                        force_push="true"
                        ;;
                esac
                shift
            done

            generate_report "$branch" "$commits" "${range:-HEAD~${commits}..HEAD}" "$first_push" "$force_push"
            ;;
        list)
            list_reports "${1:-10}"
            ;;
        latest)
            get_latest_report
            ;;
        summary)
            show_summary "${1:-}"
            ;;
        notification)
            if [ -z "${1:-}" ]; then
                echo '{"error": "Report file path required"}'
                exit 1
            fi
            generate_notification "$1" "${2:-0}" "${3:-0}" "${4:-0}" "${5:-0}"
            ;;
        message)
            if [ -z "${1:-}" ]; then
                echo "Error: Report file path required"
                exit 1
            fi
            generate_notification_message "$1" "${2:-0}" "${3:-0}" "${4:-0}" "${5:-0}"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo "Unknown command: $command"
            echo "Run '$0 help' for usage"
            exit 1
            ;;
    esac
}

# ============================================
# EXPORTS FOR SOURCING
# ============================================

# Export functions when sourced
export -f get_report_timestamp 2>/dev/null || true
export -f get_datetime 2>/dev/null || true
export -f ensure_report_dir 2>/dev/null || true
export -f init_report 2>/dev/null || true
export -f generate_summary_section 2>/dev/null || true
export -f generate_commits_section 2>/dev/null || true
export -f generate_security_section 2>/dev/null || true
export -f generate_code_quality_section 2>/dev/null || true
export -f generate_documentation_section 2>/dev/null || true
export -f generate_file_movements_section 2>/dev/null || true
export -f generate_recommendations_section 2>/dev/null || true
export -f generate_advisory_footer 2>/dev/null || true
export -f generate_report 2>/dev/null || true
export -f update_report_section 2>/dev/null || true
export -f finalize_report 2>/dev/null || true
export -f update_report_index 2>/dev/null || true
export -f generate_notification 2>/dev/null || true
export -f generate_notification_message 2>/dev/null || true
export -f list_reports 2>/dev/null || true
export -f get_latest_report 2>/dev/null || true
export -f show_summary 2>/dev/null || true

# Export configuration
export REPORT_DIR
export REPORT_SECTIONS
export TIMESTAMP_FORMAT
export DATETIME_FORMAT

# ============================================
# EXECUTION
# ============================================

# Determine if script is being sourced or executed directly
_report_sourced=false
if [ -n "${BASH_SOURCE:-}" ]; then
    if [ "${BASH_SOURCE[0]:-$0}" != "${0}" ]; then
        _report_sourced=true
    fi
elif [ -n "${ZSH_EVAL_CONTEXT:-}" ]; then
    case "$ZSH_EVAL_CONTEXT" in
        *:file*) _report_sourced=true ;;
    esac
fi

# Run main if executed directly
if [ "$_report_sourced" = "false" ]; then
    main "$@"
fi
