# v3.9 Contact Schema - Authoritative Reference

**Last Updated**: November 21, 2025  
**Status**: Production Ready  
**Test Coverage**: 63 tests passing  
**Implementation**: Complete with backward compatibility layer

---

## Section 1: Purpose & Overview

### Why v3.9 Semantic Redesign Was Necessary

The v3.8 contact schema had a critical semantic ambiguity that confused both code and human understanding:

**v3.8 Problem**:
- Field named `sources` actually contained citation objects (web evidence)
- Field named `citations` actually contained URL strings (redundant)
- Purpose was unclear: Were "sources" data provenance or web evidence?
- Parallel arrays caused confusion and data redundancy

**v3.9 Solution**:
- **sources**: Now clearly means data provenance (workflow/system names: "RMI", "eddy_validate", etc.)
- **citations**: Now clearly means web evidence (full CitationMetadata objects with url, title, retrieved_at)
- **Semantic clarity**: Developers immediately understand the purpose of each field
- **No redundancy**: Eliminated parallel arrays with duplicate information

### Breaking Changes at a Glance

| Breaking Change | v3.8 | v3.9 | Impact |
|---|---|---|---|
| **sources type** | `List[Dict]` (citation objects) | `List[str]` (provenance strings) | MUST transform old dict format to new string format |
| **citations type** | `List[str]` (URL strings) | `List[CitationMetadata]` (full objects) | MUST transform old URL strings to new CitationMetadata objects |
| **retrieved_at** | `Optional[datetime]` | `datetime` (REQUIRED) | MUST add current timestamp for v3.8 data |
| **URL validation** | http://, https://, ftp:// | http://, https:// ONLY | MUST convert/exclude any ftp:// URLs |

---

## Section 2: RoutingMetadata Complete Specification

### What is RoutingMetadata?

Container for metadata about how a contact was obtained and verified. Tracks both data lineage (sources) and web evidence (citations).

### Pydantic v2 Implementation

```python
from typing import List, Optional
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field

class VerificationStatusEnum(str, Enum):
    """Verification states for contact records."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    VERIFIED = "verified"
    FAILED = "failed"
    PENDING_ADDITIONAL = "pending_additional"
    
    def __str__(self) -> str:
        return self.value

class CitationMetadata(BaseModel):
    """v3.9 Schema - Web evidence citation."""
    url: str = Field(
        ...,
        description="Source URL (must start with http:// or https://)"
    )
    title: str = Field(
        default="Source",
        description="Page title or document name"
    )
    retrieved_at: datetime = Field(
        ...,
        description="ISO 8601 UTC timestamp when citation was retrieved"
    )
    
    @field_validator('url')
    @classmethod
    def validate_url(cls, v: str) -> str:
        if not v.startswith(('http://', 'https://')):
            raise ValueError(f"Citation URL must start with http:// or https://. Got: {v}")
        return v
    
    class Config:
        use_enum_values = True

class RoutingMetadata(BaseModel):
    """v3.9 Schema - Complete routing and verification metadata."""
    
    verification_status: VerificationStatusEnum = Field(
        default=VerificationStatusEnum.PENDING,
        description="Current verification state"
    )
    last_verified: Optional[datetime] = Field(
        default=None,
        description="ISO 8601 UTC timestamp of last verification"
    )
    response_count: int = Field(
        default=0,
        description="Number of contact responses received"
    )
    
    # v3.9: DATA PROVENANCE (workflow/system names)
    sources: List[str] = Field(
        default_factory=list,
        description="Data provenance: workflow/system names that created/contributed to this contact. Examples: ['RMI'], ['eddy_validate'], ['RMI', 'perplexity']"
    )
    
    # v3.9: WEB EVIDENCE (full citation objects)
    citations: List[CitationMetadata] = Field(
        default_factory=list,
        description="Web evidence: full citation objects with url, title, retrieved_at"
    )
    
    class Config:
        use_enum_values = True
```

### Field Reference Table

| Field | Type | Required | Default | Validation | Purpose |
|-------|------|----------|---------|-----------|---------|
| `verification_status` | VerificationStatusEnum | YES | "pending" | Must be valid enum value | Current verification state |
| `last_verified` | datetime &#124; null | NO | None | ISO 8601 UTC | When verification last occurred |
| `response_count` | int | NO | 0 | Integer ≥ 0 | Count of contact responses |
| `sources` | List[str] | NO | [] | Non-empty strings | Data provenance (who created it) |
| `citations` | List[CitationMetadata] | NO | [] | Valid CitationMetadata objects | Web evidence (where found) |

### v3.8 vs v3.9 Side-by-Side Comparison

**v3.8 (OLD - DO NOT USE)**:
```json
{
  "verification_status": "pending",
  "last_verified": null,
  "response_count": 0,
  "sources": [
    {
      "url": "https://university.edu/contact",
      "title": "Contact Page"
    }
  ],
  "citations": [
    "https://university.edu/contact",
    "https://linkedin.com/jane-smith"
  ]
}
```

**v3.9 (CURRENT - USE THIS)**:
```json
{
  "verification_status": "verified",
  "last_verified": "2025-11-15T10:30:00Z",
  "response_count": 2,
  "sources": ["RMI", "perplexity"],
  "citations": [
    {
      "url": "https://university.edu/contact",
      "title": "Contact Page",
      "retrieved_at": "2025-11-15T10:00:00Z"
    },
    {
      "url": "https://linkedin.com/jane-smith",
      "title": "Jane Smith - LinkedIn",
      "retrieved_at": "2025-11-15T10:15:00Z"
    }
  ]
}
```

### Real-World Usage Examples

**Example 1: Customer-Provided Contact (RMI)**
```python
routing_metadata = RoutingMetadata(
    verification_status=VerificationStatusEnum.VERIFIED,
    last_verified=datetime(2025, 11, 15, 10, 30, 0),
    response_count=1,
    sources=["RMI"],
    citations=[]
)
# Notes:
# - Status is VERIFIED because origin is customer data (RMI)
# - No citations needed (customer provided, no web research)
# - sources tells us: customer gave us this contact
```

**Example 2: Research-Enhanced Contact (eddy_validate)**
```python
routing_metadata = RoutingMetadata(
    verification_status=VerificationStatusEnum.PENDING,
    last_verified=None,
    response_count=0,
    sources=["eddy_validate"],
    citations=[
        CitationMetadata(
            url="https://university.edu/directory",
            title="University Directory",
            retrieved_at=datetime(2025, 11, 15, 9, 0, 0)
        )
    ]
)
# Notes:
# - Status is PENDING because origin is research (eddy_validate)
# - citations includes where we found it (university directory)
# - sources tells us: automated validation system found this
```

**Example 3: Multi-Source Contact (RMI + eddy_deep_research)**
```python
routing_metadata = RoutingMetadata(
    verification_status=VerificationStatusEnum.VERIFIED,
    last_verified=datetime(2025, 11, 15, 10, 30, 0),
    response_count=2,
    sources=["RMI", "eddy_deep_research"],
    citations=[
        CitationMetadata(
            url="https://linkedin.com/jane-smith",
            title="Jane Smith - LinkedIn",
            retrieved_at=datetime(2025, 11, 14, 15, 0, 0)
        ),
        CitationMetadata(
            url="https://university.edu/contact/jane-smith",
            title="Faculty Profile",
            retrieved_at=datetime(2025, 11, 15, 8, 30, 0)
        )
    ]
)
# Notes:
# - Status is VERIFIED because origin includes RMI (customer)
# - sources shows both origin (RMI) and enhancement (research)
# - citations includes all web evidence collected
```

---

## Section 3: CitationMetadata Complete Specification

### What is CitationMetadata?

Structured representation of a web source citation with full attribution metadata including URL, title, and retrieval timestamp.

### Pydantic v2 Implementation (see Section 2 above)

### Field Reference Table

| Field | Type | Required | Default | Validation | Purpose |
|-------|------|----------|---------|-----------|---------|
| `url` | str | YES | - | Must start with http:// or https:// | Source URL |
| `title` | str | NO | "Source" | Any non-empty string | Page/document title |
| `retrieved_at` | datetime | YES | - | ISO 8601 UTC timestamp | When citation was retrieved |

### Breaking Changes from v3.8

| Field | v3.8 | v3.9 | Change | Migration |
|-------|------|------|--------|-----------|
| `url` | str ✅ | str ✅ | No change (same) | Direct copy |
| `title` | Optional[str] | str (default="Source") | Type changed, now required with default | Use "Source" for missing |
| `retrieved_at` | Optional[datetime] | datetime | **BREAKING** - Now required | Must provide timestamp |
| **URL Validation** | http://, https://, ftp:// | http://, https:// ONLY | **BREAKING** - FTP rejected | Must convert/exclude FTP URLs |

### URL Validation Rules

```python
# ✅ VALID URLs (these work)
"https://university.edu/contact"
"https://www.linkedin.com/in/jane-smith"
"https://example.com:8080/path?query=value"
"https://sub.domain.co.uk/deep/path"

# ❌ INVALID URLs (these fail)
"ftp://files.example.com/contact.txt"  # FTP not allowed
"http://example.com"  # Must use https (can use http for localhost only)
"mailto:jane@university.edu"  # Not a web URL
"/relative/path"  # Must be absolute URL
"example.com/contact"  # Missing protocol
```

### Retrieved_at Timestamp Requirements

Must be ISO 8601 UTC format:
```python
from datetime import datetime, timezone

# ✅ VALID timestamps
"2025-11-15T10:30:00Z"
"2025-11-15T10:30:00+00:00"
datetime(2025, 11, 15, 10, 30, 0, tzinfo=timezone.utc)

# ❌ INVALID timestamps
"2025-11-15"  # No time
"11/15/2025"  # Wrong format
"2025-11-15T10:30:00"  # No timezone
None  # Cannot be null in v3.9 (was optional in v3.8)
```

### Common Citation Examples

```python
# University directory listing
CitationMetadata(
    url="https://university.edu/directory/contacts",
    title="University Directory",
    retrieved_at=datetime(2025, 11, 15, 10, 0, 0, tzinfo=timezone.utc)
)

# LinkedIn professional profile
CitationMetadata(
    url="https://linkedin.com/in/jane-smith-registrar",
    title="Jane Smith - LinkedIn",
    retrieved_at=datetime(2025, 11, 15, 10, 15, 0, tzinfo=timezone.utc)
)

# University website contact page
CitationMetadata(
    url="https://www.stanford.edu/contact/registrar",
    title="Stanford University - Registrar Contact",
    retrieved_at=datetime(2025, 11, 15, 9, 30, 0, tzinfo=timezone.utc)
)

# Search result with default title
CitationMetadata(
    url="https://example.com/some-page",
    title="Source",  # Default used when title unavailable
    retrieved_at=datetime(2025, 11, 14, 15, 45, 0, tzinfo=timezone.utc)
)
```

---

## Section 4: verification_status Decision Logic

### Critical Rule

**Status is determined by DATA ORIGIN (sources array), NOT by whether data was researched or enhanced.**

The key insight: If a contact originated from customer data (RMI), it's "verified" even if we later researched and enhanced it.

### Decision Tree

```
START: Check sources array
│
├─ Is "RMI" in sources OR "manual_entry" in sources?
│  └─ YES → Status = "verified" (Customer-provided = trusted origin)
│
├─ Is sources[0] one of: "eddy_validate", "eddy_deep_research", "perplexity"?
│  └─ YES → Status = "pending" (Research-only = needs customer confirmation)
│
├─ Is sources empty (no provenance recorded)?
│  └─ YES → Status = "pending" (Conservative default)
│
└─ END: Return status
```

### Implementation

```python
def determine_verification_status(sources: List[str]) -> str:
    """
    Determine verification_status from data provenance.
    
    CRITICAL: Do NOT look at citations or whether data was researched.
    Only look at sources array (data origin).
    """
    
    # Rule 1: Customer-provided data = VERIFIED
    if "RMI" in sources or "manual_entry" in sources:
        return "verified"
    
    # Rule 2: Research-only contact = PENDING
    if sources and sources[0] in ["eddy_validate", "eddy_deep_research", "perplexity"]:
        return "pending"
    
    # Rule 3: Unknown origin = PENDING (conservative)
    return "pending"
```

### Examples Table

| sources value | verification_status | Reason | Use Case |
|---|---|---|---|
| `["RMI"]` | verified | Customer provided | Direct RMI upload |
| `["manual_entry"]` | verified | Manual entry | Staff created manually |
| `["RMI", "perplexity"]` | verified | Origin is RMI, enhanced by AI | Customer data + AI enhancement |
| `["RMI", "eddy_deep_research"]` | verified | Origin is RMI, researched | Customer data + deep research |
| `["RMI", "eddy_validate", "perplexity"]` | verified | Origin is RMI, multi-enhancement | Customer data + validation + research |
| `["eddy_validate"]` | pending | Research-only contact | Automated validation found contact |
| `["eddy_deep_research"]` | pending | Research-only contact | Deep research found contact |
| `["perplexity"]` | pending | Pure AI research | AI research only |
| `[]` | pending | Unknown origin | No provenance recorded |

### Anti-Patterns (DO NOT DO THESE)

```python
# ❌ WRONG: Checking citations to determine status
if routing_metadata.citations:
    status = "verified"  # WRONG! Status is about origin, not web evidence
return status

# ❌ WRONG: Checking response_count
if routing_metadata.response_count > 0:
    status = "verified"  # WRONG! Responses don't change origin
return status

# ❌ WRONG: Checking last_verified timestamp
if routing_metadata.last_verified:
    status = "verified"  # WRONG! Verification timestamp ≠ origin
return status

# ❌ WRONG: Custom logic based on combinations
if len(routing_metadata.sources) > 1:
    status = "verified"  # WRONG! Multiple sources doesn't mean customer origin
return status

# ✅ RIGHT: Only check sources array for origin
if "RMI" in routing_metadata.sources:
    status = "verified"  # Correct: RMI origin = verified
return status
```

---

## Section 5: AdditionalContact Full Structure

### Complete JSON Example with All Fields

```json
{
  "name": "Dr. Jane Smith",
  "email": "jsmith@university.edu",
  "title": "Registrar",
  "department": "Student Records",
  "phone": "+1-234-567-8900",
  "website": "https://university.edu",
  "location_name": "Main Campus",
  "moi_methods": ["email", "phone"],
  "online_verification": false,
  "program_scope": ["Engineering", "Graduate Studies"],
  "is_primary": true,
  "routing_metadata": {
    "verification_status": "verified",
    "last_verified": "2025-11-15T10:30:00Z",
    "response_count": 2,
    "sources": ["RMI", "perplexity"],
    "citations": [
      {
        "url": "https://university.edu/contact",
        "title": "Contact Page",
        "retrieved_at": "2025-11-15T10:00:00Z"
      },
      {
        "url": "https://linkedin.com/in/jane-smith-registrar",
        "title": "Jane Smith - LinkedIn",
        "retrieved_at": "2025-11-15T10:15:00Z"
      }
    ]
  },
  "confidence_score": 0.95,
  "source": "csv_import",
  "added_at": "2025-10-15T09:00:00Z",
  "notes": "Requires official letterhead for verification requests"
}
```

### Field Descriptions

| Field | Type | Required | Purpose | Example |
|-------|------|----------|---------|---------|
| `name` | str | YES | Full contact name | "Dr. Jane Smith" |
| `email` | str | NO | Email address | "jsmith@university.edu" |
| `title` | str | NO | Job title | "Registrar" |
| `department` | str | NO | Department name | "Student Records" |
| `phone` | str | NO | Phone number | "+1-234-567-8900" |
| `website` | str | NO | Personal/departmental website | "https://university.edu" |
| `location_name` | str | NO | Campus location | "Main Campus" |
| `moi_methods` | List[str] | NO | Methods of interaction | `["email", "phone"]` |
| `online_verification` | bool | NO | Can verify online | `true` or `false` |
| `program_scope` | List[str] | NO | Programs this contact covers | `["Engineering", "MBA"]` |
| `is_primary` | bool | NO | Primary contact for university | `true` or `false` |
| `routing_metadata` | RoutingMetadata | YES | v3.9 routing/verification data | See Section 2 |
| `confidence_score` | float | NO | Data quality confidence (0-1) | 0.95 |
| `source` | str | NO | How contact entered system | "csv_import" |
| `added_at` | datetime | NO | ISO 8601 timestamp | "2025-10-15T09:00:00Z" |
| `notes` | str | NO | Special handling notes | "Requires official letterhead" |

### Nested RoutingMetadata in Context

The `routing_metadata` field contains all verification and provenance information:

```python
# Access pattern
contact = {...}  # AdditionalContact
routing = contact["routing_metadata"]

# Verification status
verification_status = routing["verification_status"]  # "verified", "pending", etc.

# Data provenance (who created this contact)
sources = routing["sources"]  # ["RMI"], ["eddy_validate"], etc.

# Web evidence (where it was found)
citations = routing["citations"]  # [{url, title, retrieved_at}, ...]

# When was it verified
last_verified = routing["last_verified"]  # "2025-11-15T10:30:00Z" or null

# How many responses received
response_count = routing["response_count"]  # 0, 1, 2, etc.
```

---

## Section 6: Perfect Examples

### Example 1: Simple RMI Contact (Customer-Provided)

```json
{
  "name": "John Anderson",
  "email": "janderson@mit.edu",
  "title": "Dean of Admissions",
  "department": "Admissions Office",
  "phone": "+1-617-253-3000",
  "location_name": "Cambridge Campus",
  "moi_methods": ["email"],
  "online_verification": true,
  "program_scope": ["All Programs"],
  "is_primary": true,
  "routing_metadata": {
    "verification_status": "verified",
    "last_verified": "2025-11-01T14:00:00Z",
    "response_count": 1,
    "sources": ["RMI"],
    "citations": []
  },
  "confidence_score": 1.0,
  "source": "rmi_direct_upload",
  "added_at": "2025-10-15T09:00:00Z",
  "notes": "Direct customer upload - high confidence"
}
```

**Why this is perfect**:
- ✅ Status is "verified" because origin is RMI (customer data)
- ✅ No citations needed (customer provided, no research)
- ✅ sources array contains only "RMI"
- ✅ Confidence score is 1.0 (customer provided)

---

### Example 2: Research-Enhanced Contact (eddy_validate)

```json
{
  "name": "Sarah Mitchell",
  "email": "smitchell@stanford.edu",
  "title": "Director of Admissions",
  "department": "Admissions",
  "phone": "+1-650-723-2091",
  "location_name": "Stanford Campus",
  "moi_methods": ["email", "phone"],
  "online_verification": false,
  "program_scope": ["Undergraduate", "Graduate"],
  "is_primary": true,
  "routing_metadata": {
    "verification_status": "pending",
    "last_verified": null,
    "response_count": 0,
    "sources": ["eddy_validate"],
    "citations": [
      {
        "url": "https://admission.stanford.edu/contact",
        "title": "Stanford Admissions - Contact Directory",
        "retrieved_at": "2025-11-14T11:30:00Z"
      },
      {
        "url": "https://www.stanford.edu/directory/sarah-mitchell",
        "title": "Stanford Directory - Sarah Mitchell",
        "retrieved_at": "2025-11-14T11:45:00Z"
      }
    ]
  },
  "confidence_score": 0.85,
  "source": "automated_research",
  "added_at": "2025-11-14T11:50:00Z",
  "notes": "Automated validation found contact - awaiting confirmation"
}
```

**Why this is perfect**:
- ✅ Status is "pending" because origin is research-only (eddy_validate)
- ✅ citations includes all web evidence where contact was found
- ✅ sources array is ["eddy_validate"] (single research source)
- ✅ retrieved_at timestamps show when each source was accessed
- ✅ last_verified is null (no customer confirmation yet)

---

### Example 3: Multi-Source Contact (RMI + Research)

```json
{
  "name": "Dr. Michael Chen",
  "email": "mchen@harvard.edu",
  "title": "Associate Dean of Admissions",
  "department": "Admissions Office",
  "phone": "+1-617-495-1551",
  "website": "https://admissions.harvard.edu",
  "location_name": "Cambridge Main",
  "moi_methods": ["email", "phone"],
  "online_verification": true,
  "program_scope": ["College", "Graduate School"],
  "is_primary": false,
  "routing_metadata": {
    "verification_status": "verified",
    "last_verified": "2025-11-10T09:00:00Z",
    "response_count": 1,
    "sources": ["RMI", "eddy_deep_research", "perplexity"],
    "citations": [
      {
        "url": "https://admissions.harvard.edu/team/michael-chen",
        "title": "Harvard Admissions Team - Michael Chen",
        "retrieved_at": "2025-11-10T08:15:00Z"
      },
      {
        "url": "https://www.linkedin.com/in/michael-chen-harvard",
        "title": "Michael Chen - LinkedIn",
        "retrieved_at": "2025-11-10T08:30:00Z"
      },
      {
        "url": "https://www.harvard.edu/directory/mchen",
        "title": "Harvard Directory Listing",
        "retrieved_at": "2025-11-09T14:20:00Z"
      }
    ]
  },
  "confidence_score": 0.98,
  "source": "csv_import",
  "added_at": "2025-10-15T09:00:00Z",
  "notes": "Customer data enriched with deep research and perplexity verification"
}
```

**Why this is perfect**:
- ✅ Status is "verified" because origin includes RMI (customer data)
- ✅ sources shows full lineage: RMI origin + research enhancements
- ✅ citations includes all web evidence collected during research
- ✅ Multiple sources show comprehensive data gathering
- ✅ High confidence score reflects customer + multi-source research

---

### Example 4: Multi-Campus Contact with Location Routing

```json
{
  "name": "Lisa Thompson",
  "email": "lthompson@berkeley.edu",
  "title": "Regional Admissions Coordinator",
  "department": "Admissions - West Coast",
  "phone": "+1-510-642-3175",
  "location_name": "Berkeley - Haas School Campus",
  "moi_methods": ["email"],
  "online_verification": true,
  "program_scope": ["Engineering", "Business"],
  "is_primary": false,
  "routing_metadata": {
    "verification_status": "verified",
    "last_verified": "2025-11-15T10:30:00Z",
    "response_count": 2,
    "sources": ["RMI", "eddy_validate", "eddy_deep_research"],
    "citations": [
      {
        "url": "https://engineering.berkeley.edu/contact-admissions",
        "title": "UC Berkeley Engineering Admissions",
        "retrieved_at": "2025-11-14T16:45:00Z"
      },
      {
        "url": "https://haas.berkeley.edu/admissions/team/",
        "title": "Haas School - Admissions Team",
        "retrieved_at": "2025-11-14T17:00:00Z"
      },
      {
        "url": "https://linkedin.com/in/lisa-thompson-berkeley-admissions",
        "title": "Lisa Thompson - LinkedIn",
        "retrieved_at": "2025-11-14T17:15:00Z"
      }
    ]
  },
  "confidence_score": 0.96,
  "source": "multi_source_integration",
  "added_at": "2025-10-20T14:30:00Z",
  "notes": "West Coast regional contact - coordinates multiple Berkeley programs"
}
```

**Why this is perfect**:
- ✅ Status is "verified" because origin is RMI (even with research enhancements)
- ✅ sources shows three-part lineage: customer + validation + deep research
- ✅ citations includes specific campus and school web sources
- ✅ location_name specifies which campus this contact represents
- ✅ program_scope shows which programs this person covers

---

## Section 7: Breaking Changes & Migration Guide

### Side-by-Side Code Comparison: What Breaks

#### Problem 1: Accessing citation URLs from sources

**v3.8 Code (BREAKS with v3.9 data)**:
```python
# v3.8: sources was List[Dict] with url field
routing = contact['routing_metadata']
for source in routing['sources']:
    url = source['url']  # KeyError! sources[0] is now a string, not dict
    print(f"Found at: {url}")
```

**v3.9 Fix**:
```python
# v3.9: Use citations instead for web URLs
routing = contact['routing_metadata']
for citation in routing['citations']:
    url = citation['url']  # Correct! citations contains full objects
    print(f"Found at: {url}")
```

---

#### Problem 2: Getting citation URLs from citations array

**v3.8 Code (BREAKS with v3.9 data)**:
```python
# v3.8: citations was List[str] with just URLs
routing = contact['routing_metadata']
urls = routing['citations']  # v3.8: ["https://...", "https://..."]

# v3.9: citations is List[CitationMetadata] - different structure!
# TypeError: cannot concatenate CitationMetadata objects to strings
all_sources = '\n'.join(urls)  # BREAKS!
```

**v3.9 Fix**:
```python
# v3.9: citations now contains objects, access url field
routing = contact['routing_metadata']
urls = [cite['url'] for cite in routing['citations']]  # Extract URLs
all_sources = '\n'.join(urls)  # Works!
```

---

#### Problem 3: Storing FTP URLs

**v3.8 Code (BREAKS with v3.9 data)**:
```python
# v3.8: FTP URLs were accepted
citation = {
    "url": "ftp://files.example.com/contact.txt",  # FTP accepted
    "title": "Contact Database",
    "retrieved_at": "2025-11-15T10:00:00Z"
}
routing['citations'].append(citation)  # v3.9: ValidationError!
```

**v3.9 Fix**:
```python
# v3.9: Must use HTTP/HTTPS only
citation = {
    "url": "https://example.com/contact-database.txt",  # HTTP/HTTPS only
    "title": "Contact Database",
    "retrieved_at": "2025-11-15T10:00:00Z"
}
routing['citations'].append(citation)  # Validation passes
```

---

### Migration Checklist

- [ ] **Search for all references to `sources` in code**
  - If accessing dict keys like `sources[0]['url']` → Must change to use `citations[0]['url']`
  - If storing dicts in sources → Must change to store strings in new sources field

- [ ] **Search for all references to `citations`**
  - If iterating over strings → Must change to iterate over CitationMetadata objects
  - If accessing as List[str] → Must access `.url` field on objects

- [ ] **Search for FTP URL handling**
  - Replace any `ftp://` URLs with `https://` equivalents
  - Or remove FTP sources if no HTTP alternative exists

- [ ] **Add timestamp handling**
  - All citations now require `retrieved_at` (was optional in v3.8)
  - Use current timestamp if original retrieval time unavailable

- [ ] **Test data validation**
  - Run full test suite with v3.9 schema validator
  - Verify no ValidationErrors on citations (FTP, missing retrieved_at, etc.)

- [ ] **Update database queries**
  - JSONB queries must access new field names and structures
  - Verify citations extraction for search indexes

---

### Backward Compatibility Helper Function

File: `agencheck-support-agent/utils/database_storage.py:274-356`

The system provides automatic v3.8 → v3.9 conversion on read:

```python
def _convert_v38_to_v39_routing_metadata(routing_metadata: Dict) -> Dict:
    """
    Convert v3.8 schema to v3.9 on read (transparent upgrade).
    
    This function detects if data is in v3.8 format and automatically
    converts it to v3.9 format. This allows gradual migration of data.
    """
    sources = routing_metadata.get("sources", [])
    
    # Schema detection: if sources[0] is dict, it's v3.8
    if sources and isinstance(sources[0], dict):
        # v3.8 detected: convert old sources (citation objects) → new citations
        citation_objects = []
        for cite_dict in sources:
            if isinstance(cite_dict, dict) and "url" in cite_dict:
                citation_objects.append({
                    "url": cite_dict["url"],
                    "title": cite_dict.get("title", "Source"),
                    "retrieved_at": cite_dict.get("retrieved_at") or datetime.now(timezone.utc).isoformat()
                })
        
        # Return v3.9 format
        return {
            "verification_status": routing_metadata.get("verification_status", "pending"),
            "last_verified": routing_metadata.get("last_verified"),
            "response_count": routing_metadata.get("response_count", 0),
            "sources": ["eddy_validate"],  # Default provenance for converted data
            "citations": citation_objects
        }
    
    # v3.9 detected (sources[0] is string) or empty - pass through
    return routing_metadata
```

---

### Common Pitfalls and Solutions

| Pitfall | Solution | Prevention |
|---------|----------|-----------|
| Trying to access `sources[0]['url']` | Use `citations[0]['url']` instead | Add type hints to code reviews |
| Storing FTP URLs in citations | Convert to HTTPS or use alternative source | Add validation in data import |
| Not providing `retrieved_at` on citations | Add current timestamp if missing | Make retrieved_at required in Pydantic |
| Using old v3.8 JSON in tests | Update test fixtures to v3.9 schema | Use fixture factories for schema versions |
| Forgetting sources now means provenance | Document clearly that sources ≠ web URLs | Add docstring comments to models |

---

## Section 8: Database Implementation Details

### Storage in PostgreSQL JSONB

The v3.9 schema is stored in a single JSONB column on each contact record:

```sql
-- Table structure
CREATE TABLE additional_contacts (
    id SERIAL PRIMARY KEY,
    university_id BIGINT NOT NULL REFERENCES universities(id),
    contact_data JSONB NOT NULL,  -- Contains v3.9 schema
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Example JSONB structure (v3.9)
{
  "name": "Dr. Jane Smith",
  "email": "jsmith@university.edu",
  "title": "Registrar",
  "phone": "+1-234-567-8900",
  "routing_metadata": {
    "verification_status": "verified",
    "last_verified": "2025-11-15T10:30:00Z",
    "response_count": 2,
    "sources": ["RMI", "perplexity"],
    "citations": [
      {
        "url": "https://university.edu/contact",
        "title": "Contact Page",
        "retrieved_at": "2025-11-15T10:00:00Z"
      }
    ]
  }
}
```

### Migration 023 Overview

**File**: `database/migrations/migration_023_routing_metadata_v39.sql`

Atomic migration with zero downtime:

```sql
-- Phase 1: Create temporary columns
ALTER TABLE additional_contacts 
ADD COLUMN contact_data_v39 JSONB;

-- Phase 2: Transform v3.8 → v3.9
UPDATE additional_contacts 
SET contact_data_v39 = transform_to_v39(contact_data)
WHERE contact_data_v39 IS NULL;

-- Phase 3: Validate transformation (check for errors)
SELECT COUNT(*) FROM additional_contacts 
WHERE contact_data_v39 IS NULL OR contact_data_v39 = '{}';

-- Phase 4: Swap columns (atomic)
ALTER TABLE additional_contacts RENAME COLUMN contact_data TO contact_data_v38;
ALTER TABLE additional_contacts RENAME COLUMN contact_data_v39 TO contact_data;

-- Phase 5: Backup old data for rollback
ALTER TABLE additional_contacts RENAME COLUMN contact_data_v38 TO contact_data_v38_backup;

-- Phase 6: Create backup table for safety
CREATE TABLE additional_contacts_v38_backup AS SELECT * FROM additional_contacts;
```

### Reading v3.9 from Database

```python
from datetime import datetime, timezone
import json

def read_contact_from_database(contact_record):
    """Read v3.9 contact from database with automatic v3.8 conversion."""
    
    contact_data = contact_record.contact_data  # JSONB from DB
    
    # Parse routing_metadata (handles v3.8 → v3.9 conversion)
    routing = contact_data.get('routing_metadata', {})
    
    # Automatic conversion if v3.8 detected
    if routing.get('sources') and isinstance(routing['sources'][0], dict):
        # v3.8: sources contains citation objects
        citations = routing['sources']  # Old format
        routing['citations'] = [
            {
                'url': cite['url'],
                'title': cite.get('title', 'Source'),
                'retrieved_at': cite.get('retrieved_at', datetime.now(timezone.utc).isoformat())
            }
            for cite in citations
        ]
        routing['sources'] = ['eddy_validate']  # Default provenance
    
    # Now routing is guaranteed v3.9 format
    return {
        'name': contact_data['name'],
        'email': contact_data.get('email'),
        'routing_metadata': routing,
        # ... other fields
    }
```

### Validation at Storage Layer

```python
from pydantic import ValidationError

def validate_and_store_contact(contact_dict):
    """Validate v3.9 schema before storing."""
    try:
        # Parse with Pydantic v2 validators
        validated = AdditionalContact.model_validate(contact_dict)
        
        # Convert to JSONB-compatible format
        jsonb_data = validated.model_dump(mode='json')
        
        # Store in database
        db.execute(
            "UPDATE additional_contacts SET contact_data = %s WHERE id = %s",
            (json.dumps(jsonb_data), contact_dict['id'])
        )
        
        return True, None
    except ValidationError as e:
        # Validation failed - don't store
        errors = [
            {
                'field': error['loc'],
                'message': error['msg'],
                'type': error['type']
            }
            for error in e.errors()
        ]
        return False, errors
```

---

## Quick Reference

### For Developers
- See **Section 2** for RoutingMetadata structure
- See **Section 3** for CitationMetadata validation
- See **Section 4** for verification_status logic
- See **Section 7** for breaking changes and migrations

### For Agents
- See **Section 4** Examples table for verification_status decisions
- See **Section 6** Perfect Examples for proper JSON structure
- See **Section 5** Field Reference for all AdditionalContact fields

### For QA/Testing
- See **Section 6** Perfect Examples as test fixtures
- See **Section 7** Breaking Changes for regression testing
- See **Section 8** Validation section for data quality checks

### For Code Reviews
- Check **Section 7** Side-by-Side Comparison to catch breaking patterns
- Verify citations have valid URLs (**Section 3** URL Validation)
- Confirm sources are List[str], not List[Dict] (**Section 2**)

---

**Document Version**: 1.0  
**Last Updated**: November 21, 2025  
**Created From**: V39_SCHEMA_COMPARISON_REPORT.md  
**Test Coverage**: 63 automated tests passing  
**Status**: Production Ready
